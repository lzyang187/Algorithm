# Arithmetic
算法题记录

一、数据结构

1、概述

（1）数组和字符串都是用连续内存进行存储

（2）栈与递归紧密相关

（3）队列与广度优先遍历算法紧密相关（如树的BFS）

2、数组

（1）即使我们只在数组中存储一个数字，也需要为所有的数据预先分配内存，所以数组的空间效率不是很好，经常有空闲的区域没有得到充分利用

（2）因为内存连续，根据index读写元素的时间复杂度为O(1)，时间效率很高。

（3）二维数组有行优先存储和列优先存储

3、字符串

（1）顺序存储

4、树

（1）先、中、后序遍历：有递归和非递归方式（借助栈）

（2）顺序存储结构：适用于满二叉树和完全二叉树

（3）链式存储结构：二叉链表，含有三个域：左子树指针、值、右子树指针

二、算法技巧

1、整数（正或负）去掉最后一位是 x/10 ；得到最后一位是 x % 10

2、Map常用来优化双重循环

3、位运算

（1）判断整数的奇偶：n & 1 == 1则为奇数，否则为偶数

（2）把一个整数-1，再和原整数做&运算，会把该整数最右边的1变成0。题目：输入N，输出整数N对应的二进制数中1的个数。

4、算法种类

（1）递归与循环：递归的实现方式简洁，但性能比循环差。递归由于是函数调用自身，而函数调用是有时间和空间消耗的，另外递归中有可能很多计算都是重复的（斐波那契数列）。除效率外，递归可能会引起StackOverflow的错误。

（2）查找和排序：查找（二分查找、BFS、DFS）；排序：（冒泡排序、快速排序、堆排序）

（3）回溯法：回溯法解决问题的所有选项可以用树形象的表示。当发现叶子节点不满足求解条件时，就“回溯”它的上一个节点，尝试其他选项。如果上一个节点的所有选项都已经试过不满足，则再次回溯到上一个节点。通常在二维方格运动这类问题都可以用回溯法解决。

（4）动态规划：求一个问题的最优解（一般是最大值或最小值）。而且该问题能够分解成若干子问题，而且子问题之间还有重叠的更小的子问题。应用动态规划之前要分析能否把大问题分解成小问题，分解后的每个小问题也存在最优解。如果把小问题的最优解组合起来能够得到整个问题的最优解，那么我们就可以用动态规划法。 	①由于子问题会重叠，所以一般用从下往上的顺序先解决子问题的最优解并保存在一维或二维数组中。从上往下分析问题，从下往上求解问题。

（5）贪婪算法： 保证每次操作都是局部最优的，并且最后得到的结果是全局最优的

（6）位运算：与、或、异或、左移、右移、无符号右移

（7）分治法：分而治之，把复杂问题分解为简单问题，每一步解决一个小问题。通常分治法都可以用递归的代码实现。

5、Int计算结果越界，结果可以用long，再与Integer.MAX_VALUE或MIN_VALUE比较来判断是否越界

6、常用Java的工具类：Character、Arrays、Collections、Math

7、大数的表示一般使用字符串或数组（int或char）

8、N ^ 0 = N；N ^ N = 0（任何数与0异或值不变，任何数与自己异或为0）

9、遇到难题时，画图、举例和分解这3种方法能帮助我们解决复杂问题